### 状态管理与容错机制

#### 1、状态管理

##### 1.1、状态的概念

##### 1.1.1、无状态计算的例子：消费延迟计算

![1642593334939](/assets/1642593334939.png)

假设现在有一个消息队列，消息队列中有一个生产者持续往消费队列写入消息，多个消费者分别从消息队列中读取消息。

![1642078246675](/assets/1642078246675.png)

从图上可以看出，生产者已经写入 16 条消息，Offset 停留在 15 ；有 3 个消费者，有的消费快，而有的消费慢。消费快的已经消费了 13 条数据，消费者慢的才消费了 7、8 条数据。根据输入很容易就可以计算出每个消费者的消费延时——consumer 0 落后了 5 条，consumer 1 落后了 8 条，consumer 2 落后了 3 条。

在无状态模式计算中：

- 单条输入包含所需要的所有信息
- 相同输入可以得到相同输出

##### 1.1.2、有状态计算的例子：访问量统计

![1642593770561](/assets/1642593770561.png)

对于 Nginx 访问日志，一条日志表示一个请求，记录该请求从哪里来，访问的哪个地址。要实时统计每个地址总共被访问了多少次，统计的时间节点不同，输出结果可能不同；第一次接收到 /api/a 日志时输出 count=1 ，第二次输出 count=2。

在有状态计算模式中：

- 单条输入仅包含所需的部分信息
- 相同输入可能得到不同的输出

##### 1.1.3、需要使用状态的场景举例

![1642594317865](/assets/1642594317865.png)

- **去重**：比如上游的系统数据可能会有重复，落到下游系统时希望把重复的数据都去掉。去重需要先了解哪些数据来过，哪些数据还没有来，也就是把所有的主键都记录下来，当一条数据到来后，能够看到在主键当中是否存在。
- **窗口计算**：比如统计每分钟 Nginx 日志 API 被访问了多少次。窗口是一分钟计算一次，在窗口触发前，如 08:00 ~ 08:01 这个窗口，前 59 秒的数据来了需要先放入内存，即需要把这个窗口之内的数据先保留下来，等到 8:01 时一分钟后，再将整个窗口内触发的数据输出。未触发的窗口数据也是一种状态。
- **机器学习 / 深度学习**：如训练的模型以及当前模型的参数也是一种状态，机器学习可能每次都用有一个数据集，需要在数据集上进行学习，对模型进行一个反馈。
- **访问历史数据**：比如与昨天的数据进行对比，需要访问一些历史数据。如果每次从外部去读，对资源的消耗可能比较大，所以也希望把这些历史数据也放入状态中做对比。

##### 1.2、内存管理状态

管理状态最直接的方式就是将数据都放到内存中，这也是很常见的做法。

但是，对流式作业有以下要求：

- 7*24 小时运行，高可靠；
- 数据不丢不重，恰好计算一次；
- 数据实时产出，不延迟；

基于以上要求，内存的管理就会出现一些问题。由于内存的容量是有限制的。如果要做 24 小时的窗口计算，将 24 小时的数据都放到内存，可能会出现内存不足；另外，作业是 7*24，需要保障高可用，机器若出现故障或者宕机，需要考虑如何备份及从备份中去恢复，保证运行的作业不受影响；此外，考虑横向扩展，假如网站的访问量不高，统计每个 API 访问次数的程序可以用单线程去运行，但如果网站访问量突然增加，单节点无法处理全部访问数据，此时需要增加几个节点进行横向扩展，这时数据的状态如何平均分配到新增加的节点也问题之一。因此，将数据都放到内存中，并不是最合适的一种状态管理方式。

##### 1.3、理想的状态管理

![1642594849189](/assets/1642594849189.png)

最理想的状态管理需要满足易用、高效、可靠三点需求：

- **易用**，Flink 提供了丰富的数据结构、多样的状态组织形式以及简洁的扩展接口，让状态管理更加易用；
- **高效**，实时作业一般需要更低的延迟，一旦出现故障，恢复速度也需要更快；当处理能力不够时，可以横向扩展，同时在处理备份时，不影响作业本身处理性能；
- **可靠**，Flink 提供了状态持久化，包括不丢不重的语义以及具备自动的容错能力，比如 HA，当节点挂掉后会自动拉起，不需要人工介入。

#### 2、状态的类型与使用